---
title: cpp入门
date: 2024-07-13 23:14:26
type:
comments: 
description: 'c++入门'
keywords: 'c++入门语法'
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
random:
categories: "CPP"
tags: "July"
---

# CPP入门

> 约等于C语言基础复习

## 1.第一个cpp程序

```cpp
#include <iostream>
using namespace std; // ?

int main() {
    cout << "hello world" << endl; 
    system("pause");
    return 0;
}
```

### 1.1 命名空间

​	C语言中规定变量名不能与关键字冲突，**但没有规定变量名不能与库中的变量名冲突**，在实际操作过程中会产生意想不到的错误，根据局部优先原则可能会产生歧义。

​	而在C++中，**同一个域**中不能出现两个重名的变量名/函数名，而命名空间的提出就是为了对标识符的名称进行本地化，解决命名污染的问题，作用为定义一个新的作用域。

### 1.2 作用域分解符

> A,B表示两个类，在A,B中都有成员member
>
> * A::member表示A类成员中的member
> * B::member表示B类成员中的member
>
> 前面的类不指定的时候，默认为全局，::a

* 作用域分解符``::``

### 1.3 命名空间使用介绍

> 总的来说就是区别不同作用域中相同的变量名，用命名空间来进行区分

* ``namespace``是c++的一个关键字，用来声明一个命名空间
* 我们将变量定义在自己创建的一个名为ns的命名空间，避免被污染
* 访问命名空间中的变量，需要使用作用域分解符
* 命名空间只能定义在全局，其中定义的变量为全局变量

* 命名空间中可以包括**变量，函数，结构体等**
* **命名空间可以进行无限次嵌套(多次使用作用域分解符)**
* 一个工程中同名的命名空间最终会被合并为一个命名空间

​	当我们每次要用命名空间中的变量时，都需要写很多额外的内容(分解符前缀)，有什么办法可以简化操作呢？**可以释放命名空间中的变量名**

* 用什么放什么

  ```cpp
  using namespace space1 :: space2;
  ```

* 由外向内逐层释放

  ```cpp
  using namespace space1;
  using namespace space2;
  ```

### 1.4 using namespace std

* std为c++标准库的命名空间

* ``using namespace std``即释放std空间中的变量名、函数名、类型名

* 将c++标准库中的命名空间完全展开方便，但在大型项目中可能出错，**更加建议::指明来自哪个namespace**，例如

  ```cpp
  std::cout << "hello world" << std::endl; 
  ```

## 2. 变量

> 变量的意义：方便我们管理内存空间

* 数据类型 变量名 = 变量初始值

### 2.1 常量

> 程序中不可更改的数据

​	c++中有两种定义常量的方式

* ``#define``宏常量：在文件上方定义

  ```cpp
  #define 常量名 常量值
  ```

* ``const``修饰变量

  ```cpp
  const 数据类型 变量名 = 变量值
  ```

### 2.2 关键字

> 变量名不能使用关键字

* 各种数据类型等
* 用的时候报错，不用特殊记忆

### 2.3 变量名命名规则

* 标识符不能是关键字
* 标识符只能由数字、字母、下划线
* 第一个字符为字母或下划线
* 标识符区分大小写

### 2.4 数据类型

> 为数据申请合适大小的内存空间

* 整型：整数类型，内存空间大小

  * ``short``(短整型)：2字节
  * ``int``(整型)：4字节
  * ``long``(长整型)：4字节，**和int一样**
  * ``long long``(长长整型)：8字节

* **``sizeof``关键字求出数据类型占用内存大小**

  * ``sizeof(数据类型/变量)``

* 浮点型

  * ``float``单精度：4字节，7位有效数字
  * ``double``双精度：8字节，15~16位有效数字

  * 编译器默认小数为``double``

* 科学计数法

  * ``3e2``：300
  * ``3e-2``：0.03

* 字符型

  * ``char``：1一字节

  * 单引号内只能有一个字符

    ```cpp
    char ch = '1';
    ```

  * 字符型变量并不是把字符本身放到内存中存储，而是存储对应的ascii码

* 转义字符

  * 不能显示出来的ascii字符
  * **``\\``代表一个反斜线字符**
  * 换行符``\n``
  * 水平制表符``\t``：8个字符大小对齐

*  **字符串型**

  * C风格字符串：字符数组

    ```c
    char str[] = "hello world";
    ```

  * C++风格字符串：``string``类型

    ```cpp
    #include<string>
    string str = "hello world";
    ```

* ``bool``类型：一个字节

  * ``true(1)/false(0)``

## 3. I/O

### 3.1 数据的输入

* 关键字``cin``
* 语法：``cin>>变量``

### 3.2 数据的输出

* 关键字``cout``
* 语法``cout << 变量``

## 4.运算符

### 4.1 算数运算符

* ``+ - * / %``

* `` ++ --``

  * 前置递增：先+1再计算

    ```c++
    a = 1;
    b = ++a;// b == 2 a == 2 
    ```

  * 后置递增：先计算后+1

    ```c++
    a = 1;
    b = a++; // b == 1 a == 2 
    ```

  * 前置递减

  * 后置递减

### 4.2 赋值运算符

* ``=``
* ``+= -= *= /= %=``

### 4.3 比较运算符

* ``== != < > <= >=``

### 4.4 逻辑运算符

* ``! && ||``

## 5. 流程控制结构

> 顺序 选择 循环

### 5.1 if

```c++
if(/**/){
    
} else if (/**/) {
    
} else {
    
}
```

### 5.2 三目运算符

* ``a = (condition) ? statement1 : statement2``

### 5.3 switch

```c++
switch(/*expression*/){
    case a:
        //code
        break;
    case b:
        //code 
        break;
    default:
        //code
        break;
}
```

* **需要用break退出当前执行，否则会一直向下执行**

### 5.4 while

```c++
while(/*condition*/){
    /*code*/
}
```

* ``break``跳出循环

### 5.5 do-while

```c++
do{
    /*code*/
} while (/*condition*/)
```

* 与while的区别
  * ```while```：判断条件后执行
  * ``do-while``：先执行一次后判断

### 5.6 for

```c++
for( ; ; ) {
    /*code*/
}
```

## 6. 数组

### 6.1 一维数组

* ``数据类型 数组名[数组长度]``；
* ``数据类型 数组名[数组长度] = {值1，值2...}``
* ``数据类型 数组名[] = {值1，值2,...}``

* 数组名：

  * 数组在内存中的首地址

  * 统计数组在内存中的长度

    ```c++
    sizeof(arr) / sizeof(arr[0])    
    ```

### 6.2 冒泡排序

```c++
void bubbleSort(int a[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
```

* 排序思路：需要n-1次循环，每次循环找到最大的放到数组最后，每次遍历的数组长度变小

### 6.3 二维数组

* ``数据类型 数组名[行数][列数];``
* ``数据类型 数组名[行数][列数] = {{}，{}};``
* ``数据类型 数组名[行数][列数] = {1,2,3,4}``
* ``数据类型 数组名[][列数] = {1,2,3,4};``

* **二维数组行数可以省略，列数不可以省略**

* 二维数组数组名：首地址

## 7. 函数

* 函数的声明：告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义
* 函数的声明可以有多次，但是函数的定义只能有一次
* **函数声明要在调用函数之前，函数定义可以在调用之后**

### 7.1 函数的分文件编写

> 让代码结构更加清晰

* 在``.h``头文件中编写函数的声明
* 在``.cpp``源文件中编写函数的定义
* 在使用函数的代码源文件中引用头文件
  * 使用``""``引用自定义头文件

一个简单的例子

```c++
// swap.h
#include <iostream>
using namespace std;

void swap(int *a, int *b);

// swap.cpp
#include "swap.h"

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// main.cpp
#include <iostream>
using namespace std;
#include "swap.h"


int main() {
    int a = 10;
    int b = 20;
    swap(&a, &b);
    cout << "a = " << a << ", b = " << b << endl;
    return 0;
}
```

## 8.指针

* 指针就是一个地址

* 解引用``*p``

* 指针同样是一种数据类型，**因为指针是一个地址**，

  * 在32位系统下，占4字节
  * 在64位系统下，占8字节

* 空指针：指针变量指向内存中编号为0的空间，**用于初始化指针变量**

  ```c++
  int *p = NULL;
  ```

* 野指针：指针变量指向非法的内存空间

* 常量指针：``const``修饰指针，指针的指向可以修改，但是指针指向的值不可以修改

  ```c++
  const int *p = &a;
  ```

* 指针常量：指针的指向不可以改变，但指向的值可以修改

  ```c++
  int * const p = &a;
  ```

* 指针和数组：利用指针访问数组中的元素

  * 数组首地址为数组第一个元素地址
  * 指针运算：以指向元素类型为单位移动

* 指针和函数：在函数调用的形参中

  * 值传递：不改变实参
  * 地址传递：改变实参

## 9.结构体

> 程序员自定义的数据类型

* 语法：``struct 结构体名 {结构体成员列表}``

  ```c++
  struct student {
      string name;
      int age;
      int score;
  };
  ```

* 结构体创建时，``struct``关键字可以省略，但是结构体定义时，``struct``关键字不可以省略

  ```c++
  student stu = {"Tom", 18, 100};
  ```

* 使用``.``访问成员变量

* 结构体数组

  * ``struct 结构体名 数组名[元素个数]``

* 结构体指针：通过结构体指针访问结构体中的成员变量

  * 通过``->``符号

* **结构体嵌套结构体**

  * 结构体中成员为结构体，类似于**层次关系**

  ```c++
  struct student{
      string name;
      int age;
      int score;
  };
  
  struct teacher{
      string name;
      int age;
      student students[10];
  }; 
  ```

* 结构体做函数参数：值传递/地址传递
  * 值传递不改变实参，但是在函数中局部克隆了原变量，开销较大
  * 采用地址传递并对一些成员变量加上``const``修饰可以解决开销问题





